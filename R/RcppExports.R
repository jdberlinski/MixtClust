# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

to_array <- function(sigmas, K, p) {
    .Call(`_MixtClust_to_array`, sigmas, K, p)
}

fix_var <- function(sigma, tol = 1e-3) {
    .Call(`_MixtClust_fix_var`, sigma, tol)
}

#' Mahalanobis distance
#'
#' @description Compute the squared Mahalanobis distance (fast implementation).
#'
#' @references Mahalanobis, Prasanta Chandra. "On the Generalised Distance in
#'   Statistics." Proceedings of the National Institute of Sciences of India 2
#'   (1936): 49-55.
#'
#' @param x Numeric. A vector (of length \eqn{p}) or matrix (with \eqn{p}
#'   columns).
#' @param mu Numeric. A vector of length \eqn{p}.
#' @param sigma Numeric. A \eqn{p \times p} non-negative definite matrix.
#' @param ischol Logical. Set to \code{TRUE} if \code{sigma} is provided as a
#'   Cholesky decomposition.
#'
#' @return The squared Mahalanobis distance for all rows in \code{x} and the
#'   mean vector \code{mu} with respect to covariance matrix \code{sigma},
#'   defined as \eqn{(x - \mu)' \Sigma^{-1}(x - \mu)}.
#'
#' @author Emily Goren, \email{emily.goren@gmail.com}
#'
#' @export
#'
mahalanobis <- function(x, mu, sigma, ischol = FALSE) {
    .Call(`_MixtClust_mahalanobis`, x, mu, sigma, ischol)
}

#' Multivariate t distribution
#'
#' @description Compute the density of the multivariate t distribution (fast
#'   implementation).
#'
#' @param x Numeric. A vector (of length \eqn{p}) or matrix (with \eqn{p}
#'   columns).
#' @param mu Numeric. A vector of length \eqn{p} representing the mean.
#' @param sigma Numeric. A \eqn{p \times p} non-negative definite matrix (or
#'   its Cholesky decomposition).
#' @param nu Numeric. A positive scalar representing the degrees of freedom.
#' @param logans Logical. If \code{TRUE}, the log density is returned.
#' @param ischol Logical. Set to \code{TRUE} if \code{sigma} is provided as a
#'   Cholesky decomposition.
#'
#' @return The multivariate t density for all rows in \code{x} using degrees of
#'   freedom \code{nu}, mean vector \code{mu}, and covariance matrix
#'   \code{sigma}.
#'
#' @author Emily Goren, \email{emily.goren@gmail.com}
#'
#' @export
#'
dMVT <- function(x, mu, sigma, nu, logans = FALSE, ischol = FALSE) {
    .Call(`_MixtClust_dMVT`, x, mu, sigma, nu, logans, ischol)
}

#' Multivariate t distribution with missing data
#'
#' @description Compute the marginal density of the multivariate t distribution
#'   for the observed coordinates.
#'
#' @param x Numeric. A vector (of length \eqn{p}) or matrix (with \eqn{p}
#'   columns). Missing values for row \eqn{i} correspondind to unique pattern
#'   of missingness \eqn{m} are indicated by the \eqn{m^{th}} element of the
#'   selection index list \code{D}.
#' @param mu Numeric. A vector of length \eqn{p} representing the mean.
#' @param sigma Numeric. A \eqn{p \times p} non-negative definite matrix (or
#'   its Cholesky decomposition).
#' @param nu Numeric. A postitive scalar.
#' @param grp Numeric. A vector of length \eqn{n} with elements indicating the
#'   which row of \code{Ru} to use as the observed coordinates for each of
#'   the \eqn{n} observations.
#' @param Ru Binary matrix. Each row corresponds to a unique pattern of missingness,
#' where \eqn{1} indicates observed and \eqn{0} indicates missing coordinates.
#'
#' @return The multivariate t density for all rows in \code{x} using degrees of
#'   freedom \code{nu}, mean vector \code{mu}, covariance matrix \code{sigma},
#'   and observed coordinates specified by rows in \code{Ru}.
#'
#' @author Emily Goren, \email{emily.goren@gmail.com}
#'
#' @export
#'
h <- function(x, mu, sigma, nu, grp, Ru) {
    .Call(`_MixtClust_h`, x, mu, sigma, nu, grp, Ru)
}

up_Z <- function(x, mus, sigmas, nus, pis, grp, Ru, labeled_obs, class_indicators) {
    .Call(`_MixtClust_up_Z`, x, mus, sigmas, nus, pis, grp, Ru, labeled_obs, class_indicators)
}

up_W <- function(x, mus, sigmas, nus, grp, Ru) {
    .Call(`_MixtClust_up_W`, x, mus, sigmas, nus, grp, Ru)
}

up_pi <- function(z) {
    .Call(`_MixtClust_up_pi`, z)
}

up_mu <- function(x, z, w, A) {
    .Call(`_MixtClust_up_mu`, x, z, w, A)
}

up_Sigma <- function(x, z, w, mus, A, constr) {
    .Call(`_MixtClust_up_Sigma`, x, z, w, mus, A, constr)
}

up_nu <- function(z, w, nus, ps, constr = FALSE, approx = FALSE) {
    .Call(`_MixtClust_up_nu`, z, w, nus, ps, constr, approx)
}

SOiOEOOk <- function(sigma, Ru) {
    .Call(`_MixtClust_SOiOEOOk`, sigma, Ru)
}

xhatk <- function(x, mu, grp, M, SOiOEOOk) {
    .Call(`_MixtClust_xhatk`, x, mu, grp, M, SOiOEOOk)
}

up_mu_Lin <- function(p, z, w, xhat) {
    .Call(`_MixtClust_up_mu_Lin`, p, z, w, xhat)
}

up_Sigmak_Lin <- function(M, zk, wk, mu, sigma, xhatk, grp, SOiOEOOk) {
    .Call(`_MixtClust_up_Sigmak_Lin`, M, zk, wk, mu, sigma, xhatk, grp, SOiOEOOk)
}

up_Sigma_Lin <- function(z, w, mu, sigma, xhat, grp, constr, Ru) {
    .Call(`_MixtClust_up_Sigma_Lin`, z, w, mu, sigma, xhat, grp, constr, Ru)
}

Q2 <- function(x, z, w, sigmas, mus, grp, Ru) {
    .Call(`_MixtClust_Q2`, x, z, w, sigmas, mus, grp, Ru)
}

